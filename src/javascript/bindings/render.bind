static duk_ret_t render_show_crosshair(duk_context *ctx) {
    duk_to_object(ctx, 0);
    nlohmann::json j = json::parse(duk_json_encode(ctx, -1));
    for (json::iterator it = j.begin(); it != j.end(); ++it)
    {
        if (it.key() == "visable")
        {
            renderer.show_crosshair = it.value();
        }
        if (it.key() == "pos")
        {
            for (json::iterator sub_it = it.value().begin(); sub_it != it.value().end(); ++sub_it)
            {
                if (sub_it.key() == "x")
                {
                    if (sub_it.value().is_null())
                    {
                        renderer.crosshair_pos.x = 0;
                    }
                    else
                    {
                        renderer.crosshair_pos.x = sub_it.value();
                    }
                }
                if (sub_it.key() == "y")
                {
                    if (sub_it.value().is_null())
                    {
                        renderer.crosshair_pos.y = 0;
                    }
                    else
                    {
                        renderer.crosshair_pos.y = sub_it.value();
                    }
                }
                if (sub_it.key() == "z")
                {
                    if (sub_it.value().is_null())
                    {
                        renderer.crosshair_pos.z = 0;
                    }
                    else
                    {
                        renderer.crosshair_pos.z = sub_it.value();
                    }
                }
            }
        }
    }
    //printf("visable: %d, pos_x: %.4f, pos_y: %.4f, pos_z: %.4f\n", renderer.show_crosshair, renderer.crosshair_pos.x, renderer.crosshair_pos.y, renderer.crosshair_pos.z);
    return 0;  /* no return value (= undefined) */
}
static duk_ret_t render_get_mouse(duk_context *ctx) {
    nlohmann::json j;
    glm::vec2 mouse_pos = renderer.get_mouse_in_world_coordinates();
    j["x"] = mouse_pos.x;
    j["y"] = mouse_pos.y;
    duk_push_string(ctx, j.dump().c_str());
    duk_json_decode(ctx, -1);
    return 1; 
}
static duk_ret_t render_add_entity(duk_context *ctx) {
    duk_to_object(ctx, 0);
    size_t ret = 0;
    std::string type;
    //printf("JSON encoded: %s\n", duk_json_encode(ctx, -1));
    std::string json = duk_json_encode(ctx, -1);
    nlohmann::json arg = json::parse(json);
    //std::string type_string = arg.value("type", "none");
    //printf("Type: %s\n", type_string.c_str());

    std::string entity_type = arg["type"];
    if (entity_type == "line")
    {
        glm::vec3 start;
        glm::vec3 end;
        if (arg.find("start") != arg.end())
        {
            start.x = arg.at("start").value("x", 0.0f);
            start.y = arg.at("start").value("y", 0.0f);
            start.z = arg.at("start").value("z", 0.0f);
        }
        else
        {
            start.x = 0.0f;
            start.y = 0.0f;
            start.z = 0.0f;
        }
        if (arg.find("end") != arg.end())
        {
            end.x = arg.at("end").value("x", 0.0f);
            end.y = arg.at("end").value("y", 0.0f);
            end.z = arg.at("end").value("z", 0.0f);
        }
        else
        {
            end.x = 0.0f;
            end.y = 0.0f;
            end.z = 0.0f;
        }
        entity_t e;
        e.type = entity_types::entity_line;
        if (arg.find("color") != arg.end())
        {
            e.color.x = arg.at("color").value("r", 1.0f);
            e.color.y = arg.at("color").value("g", 0.0f);
            e.color.z = arg.at("color").value("b", 0.0f);
        }
        else
        {
            e.color.x = 1.0f;
            e.color.y = 0.0f;
            e.color.z = 0.0f;
        }
        e.visable = arg.value("visable", true);
        e.layer = arg.value("layer", "default");
        line_t l;
        l.start = start;
        l.end = end;
        e.line = l;
        ret = renderer.entity_stack.size();
        renderer.entity_stack.push_back(e);
        duk_push_number(ctx, (size_t)ret);
        return 1;
    }
    else if (entity_type == "arc")
    {
        entity_t e;
        e.type = entity_types::entity_arc;
        if (arg.find("color") != arg.end())
        {
            e.color.x = arg.at("color").value("r", 1.0f);
            e.color.y = arg.at("color").value("g", 0.0f);
            e.color.z = arg.at("color").value("b", 0.0f);
        }
        else
        {
            e.color.x = 1.0f;
            e.color.y = 0.0f;
            e.color.z = 0.0f;
        }
        e.arc.start_angle = arg.value("start_angle", 0.0f);
        e.arc.end_angle = arg.value("end_angle", 0.0f);
        e.arc.radius = arg.value("radius", 0.0f);
        e.visable = arg.value("visable", true);
        e.layer = arg.value("layer", "default");
        if (arg.find("center") != arg.end())
        {
            e.arc.center.x = arg.at("center").value("x", 0.0f);
            e.arc.center.y = arg.at("center").value("y", 0.0f);
            e.arc.center.z = arg.at("center").value("z", 0.0f);
        }
        ret = renderer.entity_stack.size();
        renderer.entity_stack.push_back(e);
        duk_push_number(ctx, (size_t)ret);
        return 1;
    }
    else if (entity_type == "circle")
    {
        entity_t e;
        e.type = entity_types::entity_circle;
        if (arg.find("color") != arg.end())
        {
            e.color.x = arg.at("color").value("r", 1.0f);
            e.color.y = arg.at("color").value("g", 0.0f);
            e.color.z = arg.at("color").value("b", 0.0f);
        }
        else
        {
            e.color.x = 1.0f;
            e.color.y = 0.0f;
            e.color.z = 0.0f;
        }
        e.circle.radius = arg.value("radius", 0.0f);
        e.visable = arg.value("visable", true);
        e.layer = arg.value("layer", "default");
        if (arg.find("center") != arg.end())
        {
            e.circle.center.x = arg.at("center").value("x", 0.0f);
            e.circle.center.y = arg.at("center").value("y", 0.0f);
            e.circle.center.z = arg.at("center").value("z", 0.0f);
        }
        ret = renderer.entity_stack.size();
        renderer.entity_stack.push_back(e);
        duk_push_number(ctx, (size_t)ret);
        return 1;
    }
    else if (entity_type == "text")
    {   
        entity_t e;
        if (arg.find("position") != arg.end())
        {
            e.text.position.x = arg.at("position").value("x", 0.0f);
            e.text.position.y = arg.at("position").value("y", 0.0f);
            e.text.position.z = arg.at("position").value("z", 0.0f);
        }
        else
        {
            e.text.position.x = 0.0f;
            e.text.position.y = 0.0f;
            e.text.position.z = 0.0f;
        }
        e.type = entity_types::entity_text;
        if (arg.find("color") != arg.end())
        {
            e.color.x = arg.at("color").value("r", 1.0f);
            e.color.y = arg.at("color").value("g", 0.0f);
            e.color.z = arg.at("color").value("b", 0.0f);
        }
        else
        {
            e.color.x = 1.0f;
            e.color.y = 0.0f;
            e.color.z = 0.0f;
        }
        e.text.height = arg.value("height", 1.0f);
        e.visable = arg.value("visable", true);
        e.layer = arg.value("layer", "default");
        e.text.text = arg.value("text", "text");
        ret = renderer.entity_stack.size();
        renderer.entity_stack.push_back(e);
        duk_push_number(ctx, (size_t)ret);
        return 1;
    }
    else if (entity_type == "rectangle")
    {   
        entity_t e;
        if (arg.find("bottom_left") != arg.end())
        {
            e.rectangle.bottom_left.x = arg.at("bottom_left").value("x", 0.0f);
            e.rectangle.bottom_left.y = arg.at("bottom_left").value("y", 0.0f);
        }
        else
        {
            e.rectangle.bottom_left.x = 0.0f;
            e.rectangle.bottom_left.y = 0.0f;
        }
        if (arg.find("size") != arg.end())
        {
            e.rectangle.size.x = arg.at("size").value("x", 0.0f);
            e.rectangle.size.y = arg.at("size").value("y", 0.0f);
        }
        else
        {
            e.rectangle.bottom_left.x = 0.0f;
            e.rectangle.bottom_left.y = 0.0f;
        }
        e.type = entity_types::entity_filled_rectangle;
        if (arg.find("color") != arg.end())
        {
            e.color.x = arg.at("color").value("r", 1.0f);
            e.color.y = arg.at("color").value("g", 0.0f);
            e.color.z = arg.at("color").value("b", 0.0f);
        }
        else
        {
            e.color.x = 1.0f;
            e.color.y = 0.0f;
            e.color.z = 0.0f;
        }
        e.visable = arg.value("visable", true);
        e.layer = arg.value("layer", "default");
        ret = renderer.entity_stack.size();
        renderer.entity_stack.push_back(e);
        duk_push_number(ctx, (size_t)ret);
        return 1;
    }
    return 0; 
}
static duk_ret_t render_get_entity(duk_context *ctx) {
    int index = duk_to_int(ctx, 0);
    if (index < renderer.entity_stack.size())
    {
        nlohmann::json entity_json;
        switch (renderer.entity_stack[index].type)
        {
            case entity_types::entity_line:{
                entity_json["type"] = "line";
                entity_json["visable"] = renderer.entity_stack[index].visable;
                entity_json["layer"] = renderer.entity_stack[index].layer;
                entity_json["color"] = {{"r", renderer.entity_stack[index].color.x}, {"g", renderer.entity_stack[index].color.y}, {"b", renderer.entity_stack[index].color.z}};
                entity_json["start"] = { {"x", renderer.entity_stack[index].line.start.x}, {"y", renderer.entity_stack[index].line.start.y}, {"z", renderer.entity_stack[index].line.start.z}};
                entity_json["end"] = { {"x", renderer.entity_stack[index].line.end.x}, {"y", renderer.entity_stack[index].line.end.y}, {"z", renderer.entity_stack[index].line.end.z}};
                break;
            };
            case entity_types::entity_arc:{
                entity_json["type"] = "arc";
                break;
            };
            case entity_types::entity_circle:{
                entity_json["type"] = "circle";
                break;
            };
        }
        duk_push_string(ctx, entity_json.dump().c_str());
        duk_json_decode(ctx, -1);
        return 1;
    }
    duk_idx_t obj_idx = duk_push_object(ctx);
    duk_push_string(ctx, "no such entity");
    duk_put_prop_string(ctx, obj_idx, "status");
    return 1; 
}
static duk_ret_t render_set_entity(duk_context *ctx) {
    int index = duk_to_int(ctx, 0);
    if (index < renderer.entity_stack.size())
    {
        duk_to_object(ctx, 1);
        nlohmann::json j = json::parse(duk_json_encode(ctx, -1));
        int type = -1;
        for (json::iterator it = j.begin(); it != j.end(); ++it)
        {
            if (it.key() == "type")
            {
                if (it.value() == "line")
                {
                    type = entity_types::entity_line;
                }
                else if (it.value()  == "circle")
                {
                    type = entity_types::entity_circle;
                }
                else if (it.value()  == "arc")
                {
                    type = entity_types::entity_arc;
                }
                else if (it.value()  == "text")
                {
                    type = entity_types::entity_text;
                }
            }
        }
        for (json::iterator it = j.begin(); it != j.end(); ++it)
        {
            if (it.key() == "visable")
            {
                renderer.entity_stack[index].visable = it.value();
            }
            if (it.key() == "layer")
            {
                renderer.entity_stack[index].layer = it.value();
            }
            if (it.key() == "color")
            {
                for (json::iterator sub_it = it.value().begin(); sub_it != it.value().end(); ++sub_it)
                {
                    if (sub_it.key() == "r")
                    {
                        renderer.entity_stack[index].color.x = sub_it.value();
                    }
                    if (sub_it.key() == "g")
                    {
                        renderer.entity_stack[index].color.y = sub_it.value();
                    }
                    if (sub_it.key() == "b")
                    {
                        renderer.entity_stack[index].color.z = sub_it.value();
                    }
                }
            }
            if (it.key() == "start")
            {
                for (json::iterator sub_it = it.value().begin(); sub_it != it.value().end(); ++sub_it)
                {
                    if (sub_it.key() == "x")
                    {
                        renderer.entity_stack[index].line.start.x = sub_it.value();
                    }
                    if (sub_it.key() == "y")
                    {
                        renderer.entity_stack[index].line.start.y = sub_it.value();
                    }
                    if (sub_it.key() == "z")
                    {
                        renderer.entity_stack[index].line.start.z = sub_it.value();
                    }
                }
            }
            if (it.key() == "end")
            {
                for (json::iterator sub_it = it.value().begin(); sub_it != it.value().end(); ++sub_it)
                {
                    if (sub_it.key() == "x")
                    {
                        renderer.entity_stack[index].line.end.x = sub_it.value();
                    }
                    if (sub_it.key() == "y")
                    {
                        renderer.entity_stack[index].line.end.y = sub_it.value();
                    }
                    if (sub_it.key() == "z")
                    {
                        renderer.entity_stack[index].line.end.z = sub_it.value();
                    }
                }
            }
            if (it.key() == "position")
            {
                for (json::iterator sub_it = it.value().begin(); sub_it != it.value().end(); ++sub_it)
                {
                    if (sub_it.key() == "x")
                    {
                        renderer.entity_stack[index].text.position.x = sub_it.value();
                    }
                    if (sub_it.key() == "y")
                    {
                        renderer.entity_stack[index].text.position.y = sub_it.value();
                    }
                }
            }
            if (it.key() == "height")
            {
                renderer.entity_stack[index].text.height = it.value();
            }
        }
    }
    return 0;
}
static duk_ret_t render_stack_size(duk_context *ctx) {
    duk_push_int(ctx, renderer.entity_stack.size());
    return 1;
}
static duk_ret_t render_del_entity(duk_context *ctx) {
    renderer.entity_stack.erase(renderer.entity_stack.begin() + (int)duk_to_int(ctx, 0));
    return 0;
}
static duk_ret_t render_set_style(duk_context *ctx) {
    duk_to_object(ctx, 0);
    nlohmann::json j = json::parse(duk_json_encode(ctx, -1));
    for (json::iterator it = j.begin(); it != j.end(); ++it)
    {
        if (it.key() == "background_color")
        {
            for (json::iterator sub_it = it.value().begin(); sub_it != it.value().end(); ++sub_it)
            {
                if (sub_it.key() == "r")
                {
                    renderer.clear_color.x = (float)sub_it.value();
                }
                if (sub_it.key()  == "g")
                {
                    renderer.clear_color.y = (float)sub_it.value();
                }
                if (sub_it.key()  == "b")
                {
                    renderer.clear_color.z = (float)sub_it.value();
                }
                if (sub_it.key()  == "a")
                {
                    renderer.clear_color.w = (float)sub_it.value();
                }
            }
        }
    }
    //printf("clear_color-> r: %.4f, g: %.4f, b: %.4f, a: %.4f\n", renderer.clear_color.x, renderer.clear_color.y, renderer.clear_color.z, renderer.clear_color.w);
    return 0;
}
static duk_ret_t render_clear(duk_context *ctx) {
    renderer.entity_stack.clear();
    return 0; 
}
static duk_ret_t render_get_scroll(duk_context *ctx) {
    nlohmann::json j;
    j["horizontal"] = renderer.scroll.y;
    j["vertical"] = renderer.scroll.x;
    duk_push_string(ctx, j.dump().c_str());
    duk_json_decode(ctx, -1);
    return 1; 
}
static duk_ret_t render_pan(duk_context *ctx) {
    renderer.pan.x += duk_to_number(ctx, 0);
    renderer.pan.y += duk_to_number(ctx, 1);
    return 0;  /* 1 return value (= undefined) */
}
static duk_ret_t render_zoom(duk_context *ctx) {
    renderer.zoom += duk_to_number(ctx, 0);
    return 0;  /* 1 return value (= undefined) */
}
static duk_ret_t render_get_zoom(duk_context *ctx) {
    duk_push_number(ctx, renderer.zoom);
    return 1;  /* 1 return value (= undefined) */
}
static duk_ret_t render_set_loop_delay(duk_context *ctx) {
    renderer.loop_delay = duk_to_number(ctx, 0);
    return 0;  /* 1 return value (= undefined) */
}
void render_register_bindings()
{
    const duk_function_list_entry render_class[] = {
        { "show_crosshair", render_show_crosshair, 1 /* no args */ },
        { "get_mouse", render_get_mouse, 0 /* no args */ },
        { "add_entity", render_add_entity, 1 /* no args */ },
        { "get_entity", render_get_entity, 1 /* no args */ },
        { "set_entity", render_set_entity, 2 /* no args */ },
        { "stack_size", render_stack_size, 0 /* no args */ },
        { "del_entity", render_del_entity, 1 /* no args */ },
        { "set_style", render_set_style, 1 /* no args */ },
        { "clear", render_clear, 0 /* no args */ },
        { "get_scroll", render_get_scroll, 0 /* no args */ },
        { "pan", render_pan, 2 /* no args */ },
        { "zoom", render_zoom, 1 /* no args */ },
        { "get_zoom", render_get_zoom, 0 /* no args */ },
        { "set_loop_delay", render_set_loop_delay, 1 /* no args */ },
        { NULL, NULL, 0 }
    };
    js.bind_module("render", render_class);
}